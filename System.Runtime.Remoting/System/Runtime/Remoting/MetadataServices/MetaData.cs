namespace System.Runtime.Remoting.MetadataServices
{
    using Microsoft.CSharp;
    using System;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.Globalization;
    using System.IO;
    using System.Net;
    using System.Runtime;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Channels;
    using System.Text;

    public class MetaData
    {
        public static void ConvertCodeSourceFileToAssemblyFile(string codePath, string assemblyPath, string strongNameFilename)
        {
            ArrayList outCodeStreamList = new ArrayList();
            outCodeStreamList.Add(codePath);
            ConvertCodeSourceStreamToAssemblyFile(outCodeStreamList, assemblyPath, strongNameFilename);
        }

        public static void ConvertCodeSourceStreamToAssemblyFile(ArrayList outCodeStreamList, string assemblyPath, string strongNameFilename)
        {
            CompilerResults results = null;
            string path = "__Sn.cs";
            try
            {
                if (strongNameFilename != null)
                {
                    if (assemblyPath != null)
                    {
                        int num = assemblyPath.LastIndexOf(@"\");
                        if (num > 0)
                        {
                            path = assemblyPath.Substring(0, num + 1) + path;
                        }
                    }
                    FileStream stream = new FileStream(path, FileMode.Create, FileAccess.ReadWrite);
                    StreamWriter writer = new StreamWriter(stream, new UTF8Encoding(false, true));
                    writer.WriteLine("// CLR Remoting Autogenerated Key file (to create a key file use: sn -k tmp.key)");
                    writer.WriteLine("using System;");
                    writer.WriteLine("using System.Reflection;");
                    writer.WriteLine("[assembly: AssemblyKeyFile(@\"" + strongNameFilename + "\")]");
                    writer.WriteLine("[assembly: AssemblyVersion(@\"1.0.0.1\")]");
                    writer.Flush();
                    writer.Close();
                    stream.Close();
                    outCodeStreamList.Add(path);
                }
                string[] sources = new string[outCodeStreamList.Count];
                string[] strArray2 = new string[outCodeStreamList.Count];
                int num2 = 0;
                for (int i = 0; i < outCodeStreamList.Count; i++)
                {
                    Stream stream2;
                    bool flag = false;
                    if (outCodeStreamList[i] is string)
                    {
                        string str2 = (string) outCodeStreamList[i];
                        strArray2[i] = str2;
                        stream2 = System.IO.File.OpenRead(str2);
                        flag = true;
                    }
                    else
                    {
                        if (!(outCodeStreamList[i] is Stream))
                        {
                            throw new RemotingException(CoreChannel.GetResourceString("Remoting_UnknownObjectInCodeStreamList"));
                        }
                        stream2 = (Stream) outCodeStreamList[i];
                        strArray2[i] = "Stream" + num2++;
                    }
                    sources[i] = new StreamReader(stream2).ReadToEnd();
                    if (flag)
                    {
                        stream2.Close();
                    }
                }
                string outputName = assemblyPath;
                string[] assemblyNames = new string[] { "System.dll", "System.Runtime.Remoting.dll", "System.Data.dll", "System.Xml.dll", "System.Web.Services.dll" };
                if (sources.Length > 0)
                {
                    CodeDomProvider provider = new CSharpCodeProvider();
                    CompilerParameters options = new CompilerParameters(assemblyNames, outputName, true) {
                        GenerateExecutable = false
                    };
                    results = provider.CompileAssemblyFromSource(options, sources);
                }
            }
            catch (Exception exception)
            {
                Console.WriteLine(exception.ToString());
            }
            finally
            {
                System.IO.File.Delete(path);
            }
            if (results.Errors.HasErrors)
            {
                CompilerErrorCollection errors = results.Errors;
                if (errors.Count > 0)
                {
                    foreach (CompilerError error in errors)
                    {
                        Console.WriteLine(error.ToString());
                    }
                }
            }
        }

        [TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
        public static void ConvertSchemaStreamToCodeSourceStream(bool clientProxy, string outputDirectory, Stream inputStream, ArrayList outCodeStreamList)
        {
            ConvertSchemaStreamToCodeSourceStream(clientProxy, outputDirectory, inputStream, outCodeStreamList, "", "");
        }

        [TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
        public static void ConvertSchemaStreamToCodeSourceStream(bool clientProxy, string outputDirectory, Stream inputStream, ArrayList outCodeStreamList, string proxyUrl)
        {
            ConvertSchemaStreamToCodeSourceStream(clientProxy, outputDirectory, inputStream, outCodeStreamList, proxyUrl, "");
        }

        public static void ConvertSchemaStreamToCodeSourceStream(bool clientProxy, string outputDirectory, Stream inputStream, ArrayList outCodeStreamList, string proxyUrl, string proxyNamespace)
        {
            TextReader input = new StreamReader(inputStream);
            new SUDSParser(input, outputDirectory, outCodeStreamList, proxyUrl, clientProxy, proxyNamespace).Parse();
        }

        public static void ConvertTypesToSchemaToFile(ServiceType[] types, SdlType sdlType, string path)
        {
            ConvertTypesToSchemaToStream(types, sdlType, System.IO.File.Create(path));
        }

        public static void ConvertTypesToSchemaToFile(Type[] types, SdlType sdlType, string path)
        {
            ConvertTypesToSchemaToStream(types, sdlType, System.IO.File.Create(path));
        }

        public static void ConvertTypesToSchemaToStream(ServiceType[] serviceTypes, SdlType sdlType, Stream outputStream)
        {
            if (sdlType == SdlType.Sdl)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, CoreChannel.GetResourceString("Sdl generation is not supported"), new object[0]));
            }
            TextWriter output = new StreamWriter(outputStream, new UTF8Encoding(false, true));
            new SUDSGenerator(serviceTypes, sdlType, output).Generate();
            output.Flush();
        }

        public static void ConvertTypesToSchemaToStream(Type[] types, SdlType sdlType, Stream outputStream)
        {
            ServiceType[] serviceTypes = new ServiceType[types.Length];
            for (int i = 0; i < types.Length; i++)
            {
                serviceTypes[i] = new ServiceType(types[i]);
            }
            ConvertTypesToSchemaToStream(serviceTypes, sdlType, outputStream);
        }

        public static void RetrieveSchemaFromUrlToFile(string url, string path)
        {
            RetrieveSchemaFromUrlToStream(url, System.IO.File.Create(path));
        }

        public static void RetrieveSchemaFromUrlToStream(string url, Stream outputStream)
        {
            TextWriter writer = new StreamWriter(outputStream, new UTF8Encoding(false, true));
            writer.Write(new StreamReader(WebRequest.Create(url).GetResponse().GetResponseStream()).ReadToEnd());
            writer.Flush();
        }

        public static void SaveStreamToFile(Stream inputStream, string path)
        {
            Stream stream = System.IO.File.Create(path);
            TextWriter writer = new StreamWriter(stream, new UTF8Encoding(false, true));
            writer.Write(new StreamReader(inputStream).ReadToEnd());
            writer.Flush();
            writer.Close();
            stream.Close();
        }
    }
}

